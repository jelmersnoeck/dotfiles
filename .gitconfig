[user]
    name = Jelmer Snoeck
    email = jelmer@siphoc.com
    signingkey = C8C02ED097D5725E

[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = false

    # Edit everything with vim
    editor = vim

    # Global ignore file
    excludesfile = ~/.gitignore

[merge]
    tool = vimdiff

    # When merging, add a list of merged commits to the autogenerated commit
    # message.
    log = true

[github]
    user = jelmersnoeck

# URL overwrites
[url "git@github.com:"]
    insteadOf = https://github.com/
    insteadOf = gh

[push]
    # Make "git push" or "git push <remote>" only push the current branch to
    # the tracked branch (regardless of its remote name) as opposed to pushing
    # all branches with a matching name on the remote. See "An asymmetry
    # between git pull and push": http://longair.net/blog/?p=572
    default = tracking

[pretty]
    concise = %C(yellow)%h%C(reset) %s %C(bold black)(%an, %ar)%C(reset)%C(bold blue)%d%C(reset)

[alias]
    # When doing "git git log" or some such, do not complain about "git" not
    # being a valid Git command. This happens when copy-pasting examples, for
    # instance.
    git = !git

    # Show a concise status of the working directory, along with the branch
    # and the number of commits behind and/or ahead.
    st = status --short --branch

    # Quickly push to the most common destination.
    pom = push origin master

    # Quickly push to the origin
    po = push origin

    # Quickly pull from the origin
    pu = pull --rebase origin

    # I know "pum" could just as well stand for "PUsh" instead of "PUll", but
    # I am so used to "git pom" that "git pum" feels like a natural
    # counterpart. I always try to rebase to prevent unnecessary merge
    # commits.
    pum = pull --rebase origin master

    # Show the staged changes.
    dc = diff --cached

    # Commit
    ci = commit -S --verbose

    # Get pull request information from GitHub
    prs = fetch origin '+refs/pull/*/head:refs/pull/*'

    # Checkout pull request
    pr = git checkout refs/pull/

    # Like "git show myfile", but uses the last commit that changed "myfile".
    sl = log -n 1 -p

    # Switch branches, creating them if necessary. I want to unlearn using
    # "git checkout" for switching between branches because of the possible
    # dataloss when not paying attention. (You could see the PEBKAC, but I
    # could reply with another four letter acronym, slightly resembling TOFU.)
    #
    # Suppose I have modified a file named "password" and have two branches,
    # "password-expiry-mechanism" and "password-reset-mail". If I want to
    # switch to either branch, I would type "git checkout pass<Tab><Enter>",
    # but the autocomplete would stop at "git checkout password" because of
    # the ambiguity. Because I press <Enter> without really thinking, I have
    # now reset my "password" file. With "git go pass<Tab><Enter>", I would
    # simply have created a new branch called "password". (I would be forced
    # to use "--" to separate paths from banch names, which is a Good Thingâ„¢.)
    cob = checkout -B
    co = checkout

    # Make life easier, we only need git aa to add/remove git files
    aa = add --all

    # Show pretty log
    ll = !git pgl --all

    # Show only 20 git log items
    l = !git pgl -20

    # Show a git log with detailed log information.
    pgl = "!source ~/.githelpers && pretty_git_log"

    # Merge the current branch into another branch. This saves us time so we
    # dont' have to checkout to another branch, merge it and checkout again.
    # This also is a risk saver. This way you won't forget to switch back to a
    # branch and you'll work in the correct one.
    merge-to = "!source ~/.githelpers && git_merge_to"

[color]
    ui = auto

[init]
    templatedir = ~/.git_template

[heroku]
    account = personal

[commit]
    gpgsign = true
[gpg]
	program = gpg
;[url "/Users/jelmersnoeck/Projects/manifold/manifests/"]
	;insteadOf = https://github.com/manifoldco/kubernetes-manifests
